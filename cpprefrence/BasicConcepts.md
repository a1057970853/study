# Basic Concepts
## 中文翻译
    此部分提供详细的术语以及在描述cpp程序语言时用到的概念。
    一个cpp程序时一系列包含声明的文本文件(典型的有头文件和源文件)。它们经过翻译变成可执行程序。在cpp实现调用它的main函数时，可执行程序是被执行的。
    在cpp程序中确定的单词是被详细指定的。它们中的一部分是关键字，另一部分是标识符。在翻译过程中，注释是被忽略的。在程序中，某些字符不得不使用转移序列。
    cpp程序的实体有值、对象、引用、结构化绑定（since c++17)、函数、枚举、类型、类成员、模板、模板特例化、命名空间、参数包。预处理宏定义不是cpp的实体。
    声明可能引出实体、与名字联系起来、定义它的属性。定义使用一个实体所需的所有属性的声明是定义。一个程序必须包含仅有一个定义的非内联函数或变量(odr-used)。
    函数定义通常包括一系列的语句,其中有一些语句是表达式。表达式指定需要被程序执行的计算。
    在程序中遇到的名字是与声明相互联系的，这些声明通过名字查找来介绍它。每个名字是仅在程序的一部有效，这个部分叫做空间。一些名字有链接，链接能使它们引用相同实体，在他们出现在不同空间或翻译单元。
    在c++中每一个对象、引用、函数、表达式与一种类型联系，这种类型可能是基础的、复杂的、用户定义的、完整的、不完整的等。
    非静态的的数据成员的以声明的对象或引用时变量。
## 笔记
    cpp程序是文本文件。可执行程序调用main函数。
    cpp程序经过翻译变成可执行程序。
    cpp程序的实体有值、对象、引用、结构化绑定、函数、枚举、类型、类成员、模板、特例化模板、命名空间。宏定义不是实体。
    定义使用一个实体所需的所有属性的声明是定义。定义在程序中有且只能有一个。
## Comments
    注释是一种代码内文档。在插入到程序中后，他们会有效的被编译器忽略。它们仅供阅读源代码的人作为注释使用。虽然详细的文档不是c++标准的一部分。几个实用程序的存在解析不同风格的注释。
### Syntax（语法）
```
/* comment */   (1)
// comment      (2)
```
    1)经常作为c风格注释或多行注释
    2)经常作为c++风格注释或单行注释
### C-style
    C风格注释通常使用注释大块文本。它们被使用注释多行。插入C风格注释只需要使用/*和*/环绕需要注释的文本。这个可以导致注释的内容被忽略。虽然C风格不是C++标准的一部分，/**和*/是经常被明确的使用在文档块中。这是合法的，因为第二个星号作为注释的一部分。C风格注释不能被嵌套。
### C++-style
    C++风格注释通常被用来注释单行。多个C++风格注释被放在一起形成多行注释。C++风格注释告诉编译器忽略//和新的一行
### Notes
    因为注释在预处理阶段就被移除，宏定义不能构成注释。未结束的C风格不会从#include文件中溢出。
### 笔记
    /*和*/是C风格注释。//是C++风格注释。注释在预处理阶段被移除，所以宏定义不能构成注释且未结束的C风格不会从#include文件中溢出。

##  ASCII Chart
    详情查看对应表
##  Identifiers(标识符)
    一个标识符是任意长度的数字、下划线、小写或大写拉丁字母、大多数万国码字符。一个有效的标识符一定是以非数字开头的字符(下划线、大小写拉丁字母、万国码非数字字符)。标识符是大小写敏感的且其中每一个字符都是有效的。
### In declarations
    一个标识符可以用来命名对象、引用、函数、枚举、类型、类成员、命名空间、模板、特例化模板、参数包、goto标签、其他实体，除以下之外。
*   关键字的标识符不能被用作其他目的;
*   作为某些操作符和标点符号的替代表示形式的标识符不能用于其他目的;
*   任何地方带有双下划线的标识符都是保留的;
*   以下划线开头，后跟大写字母的标识符是保留的;
*   以下划线开头的标识符在全局命名空间中保留。
*   其他特例参考手册
"Reserved" here means that the standard library headers #define or declare such identifiers for their internal needs, the compiler may predefine non-standard identifiers of that kind, and that name mangling algorithm may assume that some of these identifiers are not in use. If the programmer uses such identifiers, the behavior is undefined.
In addition, it's undefined behavior to #define or #undef certain names in a translation unit, see reserved macro names for more details.
### Zombie identifiers
    有一些标识符在过去标准时时存在的。换句话来说，现在它们已经被移除。它们一直保留为以前的标准。详情请查看手册。
### In expressions
    命名变量、函数、概念专门化(自c++ 20起)或枚举器的标识符可以用作表达式。仅由标识符组成的表达式的结果就是由标识符命名的实体。如果标识符命名了函数、变量、模板形参对象(自c++ 20以来)或数据成员，则表达式的value类别为左值，否则为prvalue(例如，枚举数是prvalue表达式，概念的特化是bool prvalue(自c++ 20以来))。表达式的类型确定如下:
