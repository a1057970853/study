#   引言
*   设计可复用的面向对象软件困难。
*   在实践探索中，人们积累了比较通用的设计
*   文中只包含被证实的部分设计的模式
*   文中不包含未经证实的或新的设计的模式
*   文中不包含并发或分布式或实时设计的模式
##  什么是设计模式
设计模式是*对被用来在特定场景下解决一般设计问题的累和相互通信的对象描述*。设计模式四大基本要素：
1.  模式名称:对此种设计的抽象概括
2.  问题：在什么情况下应该使用该模式
3.  解决方案：此种模式的组成成分及协作方式
4.  效果：使用此种模式的好处
##  介绍某种模式的不同方面
1.  模式名
2.  模式分类
3.  意图：设计模式是做什么的、他的基本原理是什么、它解决了什么类型的设计问题
4.  别名
5.  动机：用以说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景。
6.  适用性:什么情况下使用这个设计模式
7.  结构：采用给予对象建模技术的表示法对模式中的类进行图形描述。
8.  参与者：设计模式中的类和/或对象以及它们各自的职责
9.  协作：模式的参与者怎么协作以实现它们的职责
10. 效果
11. 实现
12. 代码实例
13. 已知应用
14. 相关模式
##  设计模式的编目
### 设计模式名字与意图
1.  AbstarctFactory：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
2.  Adapter:将一个类的接口转化程客户希望的另一个接口。Adapter模式是的原本由于接口不兼容二不能一起工作的那些类可以一起工作
3.  Bridge：将抽象部分与它实现部分分离，使他们都可以独立地变化。
4.  Builder:将一个复杂对象的构建与它的表示分离，使得同样构建过程中可以创建不同的表示。
5.  ChainOfResponsibility:为接触请求的发送者和接收者之间的耦合，而使多个对象都有机会处理请求。将这些对象练成一条链，并沿着这条链传递该请求，知道有一个对象处理它。
6.  Command：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消操作。
7.  Composite：将对象组合成树形结构以表示"部分-整体”的层次结构。composite使得客户对单个对象和符合对象的使用具有一致性。
8.  Decorator：动态地给一个对象添加一些额外的职责。就拓展功能而言，Decorator模式比生成子类方式更灵活。
9.  Facade：为子系统中的一组接口提供一个一致的界面。Facade模式定义一个高层的接口，这个接口使得这一子系统更容易使用。
10. Factory Method:定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。
11. FlyWeight:运用共享技术有效地支持大量细粒度对象
12. Interpreter：给定一个语言，定义他的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
13. Iterator:提供一种方法顺序访问一个聚合对象中的各个元素，而又不报入该对象的内部表示
14. Mediator：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地互相引用，从而使其耦合松散,而且可以独立地改变它们之间的表示
15. Memento:在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将对象恢复到保存的状态。
16. Prototype：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
17. Proxy：为其他对象提供一个代理以控制对这个对象的访问
18. Singleton:保证一个类仅有一个实例，并提供一个访问它的全局访问点
19. State:允许一个对象在起内部状态改变时改变它的行为。对象看起来似乎修改了它的所属的类
20. Strategy:定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的用户。
21. TemplateMethod：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
22. Vistor:表示一个作用于某对象结构中的各个元素操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
### 组织编目
1.  以模式是用来完成什么工作的进行分类
    1.  创建型:与对象创建有关
    2.  结构型:处理类或对象的组合
    3.  行为型:对类或对象怎么交互和怎么分配职责进行描述
2.  模式主要是用于类还是用于对象
    1.  类模式：处理类和类之间的关系。
    2.  对象模式：处理对象之间的关系。
##  设计模式怎样解决设计问题
### 寻找合适的对象
*   面向对象程序有对象组成。对象包括数据和对数据进行操作的过程。其中过程也被成为操作或方法。对象在接收到客户的请求（或消息）后执行操作。
*   客户请求是使对象执行操作的唯一方法。操作有事对象改变内部数据的唯一方法。
*   面向对象设计的几种方法
    *   将名词和动词转化为创建相应类和操作
    *   关注系统协作和职责关系
    *   对现实世界建模
### 决定对象的粒度
### 指定对象接口
*   对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的型构
*   对象的所有操作型构的合集称为接口
*   类型是用来标识特定接口的一个名字
*   当一个类型的接口包含另一个类型的接口时，一个类型称为另一个类型的子类型，另一个类型称为超类型
*   动态绑定是指发送的请求直到运行时刻才收到具体实现的约束。
*   动态绑定允许你在运行是可彼此替换有相同接口的对象。这种可替换性称为多态
### 描述对象的实现
*   类继承与接口继承
    *   类继承根据一个对象的实现定义另一个对象的实现
    *   接口继承描述类一个对象什么时候能被用来替代另一个对象
*   对接口编程，而不是对实现编程
### 运用复用机制
*   继承与组合的比较
    *   继承：通过继承机制生成子类通常被称为白箱复用
        *   优点：在编译时关系就已经确定。方便实现。
        *   缺点：无法在运行时改变继承关系。子类揭示了父类的细节破坏了封装性。
    *   组合：通过组装或组合对象通常被称为黑箱复用
        *   优点：在运行时确定关系。各对象之间不知道细节，只知道接口，具有封装性。
*   优先使用对象组合，而不是类继承
*   委托:是一种组合方法。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的代理者。类似于子类请求交给父类一样。缺点是比较低效且不能建立复杂委托关系。
*   参数化类型(即模板) 
### 关联运行时刻和编译时刻的结构
*   聚合(aggregation):一个对象拥有另一个对象或对另一个对象负责。聚合意味着聚合对象和其所有者具有相同生命周期
*   相识(acquaintance)：一个对象仅仅知道另一个对象，不对其负责。
*   聚合类似于类中定义的变量，相识类似于类中指针或引用
### 设计应支持变化
设计遇到的情况，坏处及解决方案
*   通过显式地指定一个类来创建对象
    *   在创建对象是指定类名将使你受到特定实现的约束而不是特定接口的约束。
    *   这会使外来的变化更复杂。
    *   为了避免这种情况，应该间接地创建对象
    *   避免这种情况：Abstract Factory、Factory Method 、Prototype
*   对特殊模式的依赖
    *   当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来
    *   为避免把请求代码写死，你可以在编译时时刻或运行时刻很方便的改变响应请求的方式
    *   避免这种情况：Chain of Resposibility、Command
*   对硬件和软件平台的依赖
    *   外部的操作系统接口和应用编程接口在不同软硬件平台上是不同的。
    *   依赖于特定平台的软件很难移植到其他平台上，甚至都很难跟上本地平台的更新。
    *   所以设计系统是限制起平台相关性很重要
    *   避免这种情况：Abstract Factory、Bridge
*   对对象表示或实现的依赖
    *   知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。
    *   对客户隐藏这些信息能够阻止连锁变化
    *   避免这种情况的方法：Abstract Factory、Bridge、Memento、Proxy
*   算法依赖
    *   算法在开发和复用时常常被拓展、优化和替代。
    *   依赖与某个特定算法的对象算法发生变化时不得不变化
    *   隐藏有可能发生变化的算法应该被孤立起来
    *   避免这种情况的方法：Builder、Iterator、Strategy、Template Method、Visitor
*   紧耦合
    *   紧耦合的类很难独立的被复用，因为它们是相互依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体
    *   松耦合提高一个类本身被复用的可能性，并且系统更易于学习、移植、修改和拓展。
    *   设计模式使用抽象耦合和分层技术来提高系统的松散耦合性
    *   设计模式：Abstract Factory、Command、Facade、Mediator、Observer、Chain of Responsibility
*   通过生成子类来扩充功能
    *   通常很难通过定义自来定制对象。
    *   使用组合技术和具体的委托技术对于比较复杂的情况难以解决
    *   设计模式：Chain of Responsibility、Composite、Decorator、Observer、Strategy
*   不能方便地对类进行修改
    *   有时你不得不改变一个难以修改的类。
    *   设计模式:Adapter、Decorator、Visitor
### 依据不同类型程序所考虑的方向
1.  应用程序
    1.  以制作文本编辑器这样的应用程序为例
    2.  要优先考虑内部复用性、可维护性、可拓展性
        1.  内部复用性：确保你不会做多余的设计和实现。设计模式通过减少依赖性来提高内部复用性。松耦合也增强了一类对象与其他多个对象协作的可能性
        2.  可维护性：当设计模式被用来对系统分层和限制对平台的依赖性时应用可维护
        3.  可拓展性：当设计模式被用来对系统分层和限制对平台的依赖性时应用可拓展
2.  工具箱
    1.  工具箱是一组相关、可复用的类的集合
    2.  工具箱强调代码复用、可用、有效
3.  框架
    1.  框架是构成一类特定软件可复用设计的一组相互协作的类
    2.  它定义了整体结构、类和对象的分割、各部分的主要责任、类和对象怎么协作、以及控制流程
    3.  框架强调设计复用
### 设计模式与框架的区别
1.  设计模式比框架更抽象
2.  设计模式比框架更小的体系结构元素
3.  框架比设计模式更特例化
## 怎样选择设计模式
1.  考虑设计模式是怎样解决设计问题
2.  浏览模式的意图部分
3.  研究模式怎样相互关联
4.  检查重新设计的原因
5.  考虑你的设计中哪些是可变的

|目的|设计模式|可变的方面|
|---|-------|-------|
|创建|AbstractFactory|生产对象家族|
|创建|Builder|如何构建一个组合对象|
|创建|FactoryMethod|被实例化的子类|
|创建|Prototype|被实例化的类|
|创建|Singleton|一个类的唯一实例|
|结构|Adapter|对象的接口|
|结构|Bridge|对象的实现|
|结构|Composite|一个对象的结构和组成|
|结构|Decorator|对象的职责，不生成子类|
|结构|Facade|一个子系统的接口|
|结构|Flyweight|对象的存储开销|
|结构|Proxy|如何访问一个对象；该对象的位置|
|行为|ChainOfResponsibility|满足一个请求的对象|
|行为|Command|何时、怎样满足一个请求|
|行为|Interpreter|一个语言的文法及解释|
|行为|Iterator|如何遍历、访问一个聚合的各元素|
|行为|Mediator|对象间怎样交互、和谁交互|
|行为|Memento|一个对象中那些私有信息存放在该对象之外，以及在什么时候进行存储|
|行为|Observer|多个对象依赖于另一个对象，而这些对象又如何保持一致|
|行为|state|对象的状态|
|行为|Strategy|算法|
|行为|TemplateMethod|算法中的某些步骤|
|行为|Visitor|某些可作用一个对象上的操作，但不修改这些对象的类|
## 怎样使用设计模式
1.  大致浏览一遍模式
2.  回头研究结构部分、参与者部分和协作部分
3.  看代码示例部分
4.  选择模式参与者的名字，使它们在应用上下文有意义
5.  定义类
6.  定义模式中专用于应用的操作名称
7.  实现执行模式中责任和协作的操作